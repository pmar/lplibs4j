package org.lplibs4j.api.problems;

import org.lplibs4j.api.constraints.Constraint;
import org.lplibs4j.api.constraints.Convertable;
import org.lplibs4j.api.constraints.LinearConstraint;
import org.lplibs4j.api.constraints.MathematicalProgram;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.HashMap;

/**
 * User: pmar@ppolabs.com
 * Date: 12/04/13
 * Time: 10:56 PM
 */
public abstract class LinearProgram extends MathematicalProgram implements ConstrainedProblem {

    HashMap<String, Integer> indexmap;

    /**
     * Marks a variable as boolean. Note: A variable is not directly marked as boolean but as an
     * integer with 0 <= x_i <= 1.
     *
     * @param i The index of the variable.
     */
    public void setBinary(int i) {
        isboolean[i] = true;
        isinteger[i] = true;
    }

    /**
     * Sets the whole list of constraints at once. Note that the existing constraints
     * are immediately overwritten without any further checking or copying and are
     * simply lost. Therefore, the user might want to check, if there are any previous
     * constraints, before he sets the complete list. Generally, it's recommended to use
     * the <code>addConstraint</code> method for adding constraints to a problem model.
     *
     * On the other hand, this method can be used to delete constraints from a model, but
     * the user has to ensure that a valid <code>ArrayList&lt;Constraint&gt;</code> is
     * passed. This method will accept the <code>null</code> value, but this will lead to
     * invalid states.
     *
     * @param constraints the new constraint list
     */
    void setConstraints(ArrayList<Constraint> constraints) {
        this.constraints = constraints;
    }

    /**
     * Adds a linear constraint to the model. If no deletion operation is needed,
     * this method is to be preferred before using <code>setConstraints</code>.
     *
     * @param c the linear constraint to be added
     * @return <code>true</code>, if the constraint was succesfully added,
     * otherwise <code>false</code>
     */
    public boolean addConstraint(LinearConstraint c) {
        return constraints.add(c);
    }

    /**
     * Adds a list of linear constraint to the model. If no deletion operation is needed,
     * this method is to be preferred before using <code>setConstraints</code>.
     *
     * @param c the linear constraint to be added
     * @return <code>true</code>, if the constraint was succesfully added,
     * otherwise <code>false</code>
     */
    boolean addConstraints(ArrayList<LinearConstraint> c){
        return constraints.addAll(c);
    }

    // RFC by Schobi: why should we return a StringBuffer rather than a String?
    //			      Do we want the users to be able to modify the output anyway
    /**
     * Converts a given linear program into the CPLEX file format.
     * @return A StringBuffer containing the linear problem specifications in the CPLEX format
     */
    public StringBuffer convertToCPLEX(){
        if (indexmap == null) {
            // TODO
        }
        StringBuffer result = new StringBuffer();

        result.append("\\ This file is autogenerated by the SCPSolver framework\n");
        result.append("\\ Modify at your own risk\n\n");

        // Writing the objective
        result.append( ( minproblem ? "MINIMIZE\n" : "MAXIMIZE\n") );

        // Just give the function a name ...
        result.append(" obj:");
        for (int i = 0; i < this.getC().length ; i++) {
            BigDecimal coeff = new BigDecimal(this.getC()[i]);

            if (coeff.signum() < 0)
                result.append(" -");
            else if (i > 0)
                result.append(" + ");
                // Just some eye-candy
            else if (i == 0)
                result.append(" ");

            if (coeff.abs().intValue() != 1)
                result.append(coeff.abs().toString());

            result.append(" x" + i);
        }
        result.append("\n");

        // Writing the constraints
        result.append("SUBJECT TO\n");
        for (Constraint c : constraints)
            result.append(( (Convertable) c).convertToCPLEX());

        // Writing the bounds
        if (this.hasBounds()) {
            result.append("Bounds\n");

            for (int i = 0; i < upperbound.length ; i++) {

                if (lowerbound[i] == - Double.MAX_VALUE )
                    result.append( " -infinity");
                else
                    result.append( " " + lowerbound[i] );

                result.append( " <= x" + i + " <= ");

                if(upperbound[i] == Double.MAX_VALUE )
                    result.append( "+infinity\n");
                else
                    result.append( upperbound[i] + "\n");
            }
        }

        // Writing the  section, if necessary
        boolean sectionwritten = false;
        for (int i = 0; i < isinteger.length; i++) {
            if (isinteger[i] && !sectionwritten) {
                result.append("GENERAL\n");
                sectionwritten = true;
            }
            if (isinteger[i])
                result.append(" x" + i + "\n");
        }

        if (sectionwritten)
            result.append("\n");

        // Finish the whole thing and we're done
        result.append("END\n");
        return result;

    }

    HashMap<String, Integer> getIndexmap() {
        return indexmap;
    }

    public void setIndexmap(HashMap<String, Integer> indexmap){
        this.indexmap = indexmap;
    }
}
